<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Santa's Reliable Delivery</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #0d1b2a;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-family: sans-serif;
            font-size: 14px;
            background: rgba(0,0,0,0.4);
            padding: 8px 12px;
            border-radius: 6px;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="ui">State: <span id="state-display">Initializing</span></div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const ui = document.getElementById('state-display');

        let width = window.innerWidth;
        let height = window.innerHeight;

        // --- CONFIG ---
        const CONFIG = {
            houseSpacing: 2200,
            groundHeight: 100, // Distance from bottom
            flightLevel: 180   // Distance from Top
        };

        // --- STATE ---
        const camera = { x: 0 };
        const world = {
            houses: [],
            scenery: [],
            stars: [],
            snow: []
        };
        
        const santa = {
            x: 0, y: 0,
            vx: 0, vy: 0,
            mode: 'FLYING',
            targetHouse: null,
            timer: 0,
            frame: 0,
            dir: 1,
            localX: 0,
            localY: 0
        };

        // --- INIT & RESIZE ---
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;

            // DYNAMIC LAYOUT
            if (height < 500) {
                CONFIG.groundHeight = 60;
            } else {
                CONFIG.groundHeight = 100;
            }

            const desiredClearance = 320;
            let groundY = height - CONFIG.groundHeight;
            let flightY = groundY - desiredClearance;

            if (flightY < 50) flightY = 50;

            CONFIG.flightLevel = flightY;

            if(world.stars.length === 0) initStars();
        }

        function initStars() {
            world.stars = [];
            const count = Math.floor((width * height) / 8000); 
            for(let i=0; i<count; i++) {
                world.stars.push({
                    x: Math.random() * width * 2,
                    y: Math.random() * (height - CONFIG.groundHeight),
                    size: Math.random() * 2 + 0.5,
                    alpha: Math.random()
                });
            }
        }

        function initSnow() {
            world.snow = [];
            for(let i=0; i<250; i++) {
                world.snow.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: Math.random() * 3 + 2,
                    size: Math.random() * 3
                });
            }
        }

        // --- GENERATION ---
        function getGroundY(x) {
            return (height - CONFIG.groundHeight) + Math.sin(x * 0.001) * 40;
        }

        function createScenery(minX, maxX) {
            const items = [];
            const space = maxX - minX;
            if (space < 100) return items;

            if (Math.random() > 0.3) items.push(generateItem(minX + 20 + Math.random() * 50));
            if (Math.random() > 0.3) items.push(generateItem(maxX - 20 - Math.random() * 50));

            const fillerCount = Math.floor(space / 400); 
            for(let i=0; i<fillerCount; i++) {
                const x = minX + 100 + Math.random() * (space - 200);
                items.push(generateItem(x));
            }
            return items;
        }

        function generateItem(x) {
            const type = Math.random() > 0.3 ? 'tree' : 'snowman';
            const depthOffset = (Math.random() - 0.5) * 20;
            const y = getGroundY(x) + depthOffset;

            let props = {};
            if(type === 'tree') {
                const scale = 0.8 + (depthOffset / 40) + Math.random() * 0.4;
                props = {
                    h: (60 + Math.random() * 80) * scale,
                    w: (30 + Math.random() * 20) * scale
                };
            } else {
                const scale = 0.7 + (depthOffset / 40) + Math.random() * 0.3;
                props = { 
                    s: scale,
                    balls: Math.random() > 0.5 ? 2 : 3
                };
            }
            return { x, y, type, props };
        }

        function createHouse(index) {
            const x = index * CONFIG.houseSpacing + 1000;
            const groundY = getGroundY(x);
            
            const w = 180 + Math.random() * 100;
            const h = 120 + Math.random() * 60;
            
            const roofType = Math.random() > 0.7 ? 'gambrel' : 'pitched';
            const roofH = 70 + Math.random() * 50;
            const roofPeakY = groundY - h - roofH;
            const roofColor = Math.random() > 0.5 ? "#cfd8dc" : "#b0bec5"; 

            let numWindows = 2;
            const rand = Math.random();
            if (w < 220) {
                if (rand > 0.9) numWindows = 1;
                else if (rand > 0.8) numWindows = 3;
                else numWindows = 2;
            } else {
                if (rand > 0.6) numWindows = 3;
                else if (rand > 0.9) numWindows = 4;
                else numWindows = 2;
            }

            const doorXOffset = (Math.random() * (w * 0.3)) * (Math.random() > 0.5 ? 1 : -1);

            const chimW = 40 + Math.random() * 10;
            const chimH = 45 + Math.random() * 20;
            const maxOffset = (w * 0.35); 
            const chimX = x + (Math.random() * maxOffset * (Math.random() > 0.5 ? 1 : -1)); 
            
            let roofYAtChim;
            if (roofType === 'pitched') {
                const slope = roofH / (w/2);
                const distFromCenter = Math.abs(chimX - x);
                roofYAtChim = roofPeakY + (distFromCenter * slope);
            } else {
                const slope1 = roofH * 0.7 / (w * 0.2); 
                const slope2 = roofH * 0.3 / (w * 0.3); 
                const distFromCenter = Math.abs(chimX - x);
                if (distFromCenter < w * 0.2) {
                    roofYAtChim = roofPeakY + (distFromCenter * slope2);
                } else {
                    roofYAtChim = roofPeakY + (w*0.2 * slope2) + ((distFromCenter - w*0.2) * slope1);
                }
            }
            
            const chimTopY = roofYAtChim - chimH;
            
            const hue = Math.random() * 360;
            const color = `hsl(${hue}, ${30 + Math.random()*20}%, ${25 + Math.random()*15}%)`;
            const lightColor = `hsl(${hue}, 80%, 75%)`;

            const gapStart = x - CONFIG.houseSpacing + 200; 
            const gapEnd = x - w/2 - 40; 
            const newScenery = createScenery(gapStart, gapEnd);
            world.scenery.push(...newScenery);

            return {
                id: index,
                x, y: groundY,
                w, h, roofH, roofPeakY, roofType, roofColor,
                numWindows, doorXOffset,
                chimX, chimW, chimH,
                chimTopY,
                chimBaseY: roofYAtChim,
                color, lightColor,
                lit: true,
                visited: false // FIX: Logic flag to prevent re-delivery
            };
        }

        function updateWorld() {
            world.houses.forEach(h => {
                const newGroundY = getGroundY(h.x);
                const dy = newGroundY - h.y;
                if (dy !== 0) {
                    h.y = newGroundY;
                    h.roofPeakY += dy;
                    h.chimTopY += dy;
                    h.chimBaseY += dy;
                }
            });
            world.scenery.forEach(s => {
                const newY = getGroundY(s.x);
                if (Math.abs(s.y - newY) > 50) s.y = newY; 
            });

            const camRight = camera.x + width + 2500;
            const nextIndex = Math.floor(camRight / CONFIG.houseSpacing);
            
            if (!world.houses.find(h => h.id === nextIndex)) {
                world.houses.push(createHouse(nextIndex));
            }
            
            const cleanupThreshold = camera.x - 1500;
            world.houses = world.houses.filter(h => h.x > cleanupThreshold);
            world.scenery = world.scenery.filter(s => s.x > cleanupThreshold);
        }

        // --- LOGIC ---
        function updateSanta() {
            santa.frame++;

            switch(santa.mode) {
                case 'FLYING':
                    santa.vx += (10 - santa.vx) * 0.05;
                    santa.vy = Math.sin(santa.frame * 0.05) * 2;
                    santa.x += santa.vx;
                    
                    const targetY = CONFIG.flightLevel + santa.vy;
                    santa.y += (targetY - santa.y) * 0.1;
                    
                    // FIX: Filter by !h.visited
                    const target = world.houses.find(h => h.x > santa.x + 100 && !h.visited);
                    
                    if(target && target.x - santa.x < 1200) {
                        santa.targetHouse = target;
                        santa.mode = 'APPROACH';
                        target.visited = true; // FIX: Mark as visited immediately upon lock-on
                    }
                    break;

                case 'APPROACH':
                    const parkX = santa.targetHouse.x - (santa.targetHouse.w/2) - 80;
                    const parkY = santa.targetHouse.roofPeakY + 20;
                    
                    const dx = parkX - santa.x;
                    const dy = parkY - santa.y;
                    santa.vx = dx * 0.04;
                    santa.vy = dy * 0.04;
                    santa.x += santa.vx;
                    santa.y += santa.vy;

                    if(Math.abs(dx) < 5 && Math.abs(dy) < 5) {
                        santa.mode = 'WALK';
                        santa.vx = 0; santa.vy = 0;
                        santa.localX = 0; santa.localY = 0;
                    }
                    break;

                case 'WALK':
                    const pX = santa.targetHouse.x - (santa.targetHouse.w/2) - 80;
                    const cX = santa.targetHouse.chimX;
                    const dist = cX - pX;

                    if(santa.localX < dist) {
                        santa.localX += 3;
                        santa.dir = 1;
                        santa.localY = -Math.abs(Math.sin(santa.frame * 0.5)) * 5;
                    } else {
                        santa.mode = 'JUMP';
                        santa.localY = 0;
                        santa.timer = 0;
                    }
                    break;

                case 'JUMP':
                    santa.timer++;
                    if(santa.timer < 15) santa.localY -= 3;
                    else santa.localY += 4;
                    
                    if(santa.localY > santa.targetHouse.chimH + 40) {
                        santa.mode = 'DELIVER';
                        santa.timer = 60 + Math.floor(Math.random() * 60); 
                    }
                    break;

                case 'DELIVER':
                    santa.timer--;
                    if(santa.timer % 8 === 0) santa.targetHouse.lit = !santa.targetHouse.lit;
                    if(santa.timer <= 0) {
                        santa.targetHouse.lit = true;
                        santa.mode = 'EXIT';
                    }
                    break;

                case 'EXIT':
                    santa.localY -= 5;
                    if(santa.localY <= 0) {
                        santa.localY = 0;
                        santa.mode = 'RETURN';
                    }
                    break;

                case 'RETURN':
                    if(santa.localX > 0) {
                        santa.localX -= 4;
                        santa.dir = -1;
                        santa.localY = -Math.abs(Math.sin(santa.frame * 0.6)) * 5;
                    } else {
                        santa.mode = 'TAKEOFF';
                        santa.timer = 20;
                        santa.dir = 1;
                    }
                    break;

                case 'TAKEOFF':
                    santa.timer--;
                    if(santa.timer <= 0) {
                        santa.vx += 0.5;
                        santa.vy -= 0.3;
                        santa.x += santa.vx;
                        santa.y += santa.vy;
                        
                        if(santa.y < CONFIG.flightLevel + 50) {
                            santa.mode = 'FLYING';
                            santa.targetHouse = null;
                        }
                    }
                    break;
            }

            const camTarget = santa.x - width * 0.3;
            camera.x += (camTarget - camera.x) * 0.1;
            ui.innerText = santa.mode;
        }

        function updateSnow() {
            world.snow.forEach(s => {
                s.x += s.vx; s.y += s.vy;
                if(s.y > height) s.y = -10;
                if(s.x < camera.x - 100) s.x += width + 200;
                if(s.x > camera.x + width + 100) s.x -= (width + 200);
            });
        }

        // --- DRAWING ---

        function drawBackground() {
            const g = ctx.createLinearGradient(0,0,0,height);
            g.addColorStop(0, "#000");
            g.addColorStop(1, "#1a237e");
            ctx.fillStyle = g;
            ctx.fillRect(0,0,width,height);

            ctx.fillStyle = "white";
            world.stars.forEach(s => {
                let dx = (s.x - camera.x * 0.1) % (width * 2);
                if(dx < 0) dx += width * 2;
                if(dx > width) return;
                ctx.globalAlpha = s.alpha;
                ctx.beginPath(); ctx.arc(dx, s.y, s.size, 0, Math.PI*2); ctx.fill();
            });
            ctx.globalAlpha = 1;

            const moonCycle = CONFIG.houseSpacing * 20; 
            const progress = (camera.x % moonCycle) / moonCycle;
            const mx = (width + 200) - (progress * (width * 3));

            ctx.fillStyle = "#fff9c4";
            ctx.shadowBlur = 40; ctx.shadowColor = "#fff9c4";
            ctx.beginPath(); ctx.arc(mx, 100, 40, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawGround() {
            ctx.fillStyle = "#eceff1";
            ctx.beginPath();
            const sx = Math.floor(camera.x/100)*100 - 200;
            const ex = sx + width + 400;
            ctx.moveTo(sx, height);
            for(let x=sx; x<=ex; x+=50) ctx.lineTo(x, getGroundY(x));
            ctx.lineTo(ex, height);
            ctx.fill();
        }

        function drawSceneryItem(s) {
            ctx.save();
            ctx.translate(s.x, s.y);

            if (s.type === 'tree') {
                const h = s.props.h;
                const w = s.props.w;
                
                ctx.fillStyle = "#3e2723";
                ctx.fillRect(-w*0.2, -h*0.2, w*0.4, h*0.2);
                
                ctx.fillStyle = "#1b5e20"; 
                ctx.beginPath(); ctx.moveTo(-w, -h*0.2); ctx.lineTo(0, -h*0.6); ctx.lineTo(w, -h*0.2); ctx.fill();
                ctx.beginPath(); ctx.moveTo(-w*0.8, -h*0.4); ctx.lineTo(0, -h*0.8); ctx.lineTo(w*0.8, -h*0.4); ctx.fill();
                ctx.beginPath(); ctx.moveTo(-w*0.6, -h*0.6); ctx.lineTo(0, -h); ctx.lineTo(w*0.6, -h*0.6); ctx.fill();
                
                ctx.fillStyle = "white";
                ctx.beginPath(); ctx.moveTo(0, -h); ctx.lineTo(-w*0.2, -h*0.85); ctx.lineTo(w*0.2, -h*0.85); ctx.fill();

            } else {
                const sc = s.props.s;
                const balls = s.props.balls || 3;
                ctx.scale(sc, sc);
                ctx.fillStyle = "white";

                let headY = 0;

                if (balls === 2) {
                    ctx.beginPath(); ctx.arc(0, -30, 30, 0, Math.PI*2); ctx.fill(); 
                    ctx.beginPath(); ctx.arc(0, -75, 22, 0, Math.PI*2); ctx.fill(); 
                    headY = -75;
                    ctx.strokeStyle = "#3e2723"; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(-25, -50); ctx.lineTo(-45, -65); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(25, -50); ctx.lineTo(45, -65); ctx.stroke();
                } else {
                    ctx.beginPath(); ctx.arc(0, -25, 25, 0, Math.PI*2); ctx.fill(); 
                    ctx.beginPath(); ctx.arc(0, -60, 20, 0, Math.PI*2); ctx.fill(); 
                    ctx.beginPath(); ctx.arc(0, -90, 15, 0, Math.PI*2); ctx.fill(); 
                    headY = -90;
                    ctx.strokeStyle = "#3e2723"; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(-15, -60); ctx.lineTo(-35, -75); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(15, -60); ctx.lineTo(35, -75); ctx.stroke();
                }
                
                ctx.fillStyle = "black";
                ctx.beginPath(); ctx.arc(-5, headY - 5, 2, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(5, headY - 5, 2, 0, Math.PI*2); ctx.fill();
                
                ctx.fillStyle = "orange";
                ctx.beginPath(); ctx.moveTo(0, headY); ctx.lineTo(15, headY + 5); ctx.lineTo(0, headY + 5); ctx.fill();
            }
            
            ctx.restore();
        }

        function drawHouseBase(h) {
            ctx.fillStyle = h.color;
            ctx.fillRect(h.x - h.w/2, h.y - h.h, h.w, h.h);

            ctx.fillStyle = h.lit ? h.lightColor : "#333";
            if(h.lit) { ctx.shadowColor="orange"; ctx.shadowBlur=20; }
            
            const winY = h.y - h.h + 40;
            const winSize = 30;
            const totalWindowWidth = h.numWindows * winSize;
            const availableSpace = h.w - 20; 
            const spacing = (availableSpace - totalWindowWidth) / (h.numWindows + 1);
            
            for(let i=0; i<h.numWindows; i++) {
                const wx = (h.x - h.w/2 + 10) + spacing + i*(winSize + spacing);
                ctx.fillRect(wx, winY, winSize, winSize);
            }
            ctx.shadowBlur = 0;

            ctx.fillStyle = "#3e2723";
            ctx.fillRect(h.x + h.doorXOffset - 15, h.y - 50, 30, 50);

            ctx.fillStyle = h.roofColor;
            ctx.beginPath();
            ctx.moveTo(h.x - h.w/2 - 20, h.y - h.h);
            if (h.roofType === 'pitched') {
                ctx.lineTo(h.x, h.roofPeakY);
            } else {
                ctx.lineTo(h.x - h.w*0.2, h.roofPeakY + h.roofH*0.3);
                ctx.lineTo(h.x, h.roofPeakY);
                ctx.lineTo(h.x + h.w*0.2, h.roofPeakY + h.roofH*0.3);
            }
            ctx.lineTo(h.x + h.w/2 + 20, h.y - h.h);
            ctx.fill();

            ctx.fillStyle = "#111";
            ctx.fillRect(h.chimX - h.chimW/2 + 2, h.chimTopY, h.chimW - 4, h.chimH);
        }

        function drawSantaLayer() {
            let rx, ry;
            let drawSleigh = false;
            let isInside = false;
            let chimBottom = 0;

            if(['FLYING', 'APPROACH', 'TAKEOFF'].includes(santa.mode)) {
                rx = santa.x; ry = santa.y;
                drawSleigh = true;
            } else {
                if(!santa.targetHouse) return;
                const pX = santa.targetHouse.x - (santa.targetHouse.w/2) - 80;
                const pY = santa.targetHouse.roofPeakY + 20;
                
                drawSleighObj(pX, pY, false); 

                if(['JUMP', 'DELIVER', 'EXIT'].includes(santa.mode)) {
                    rx = santa.targetHouse.chimX;
                    ry = santa.targetHouse.chimTopY + santa.localY;
                    isInside = true;
                    chimBottom = santa.targetHouse.chimBaseY;
                } else {
                    rx = pX + santa.localX;
                    ry = pY + santa.localY;
                }
                
                ctx.save();
                if(isInside) {
                    ctx.beginPath();
                    ctx.rect(rx - 100, -1000, 200, chimBottom + 1000);
                    ctx.clip();
                }
                drawCharacter(rx, ry, santa.dir);
                ctx.restore();
                return;
            }

            if(drawSleigh) drawSleighObj(rx, ry, true);
        }

        function drawSleighObj(x, y, withSanta) {
            ctx.save();
            ctx.translate(x, y);
            
            for(let i=0; i<3; i++) {
                let dx = 100 + i*50;
                let dy = 10 + Math.sin(santa.frame*0.2 + i)*5;
                ctx.fillStyle = "#5d4037"; ctx.fillRect(dx, dy, 30, 15);
                ctx.beginPath(); ctx.arc(dx+30, dy-2, 8, 0, Math.PI*2); ctx.fill();
                
                if(i==2) { 
                    const glow = Math.abs(Math.sin(santa.frame * 0.1)) * 15 + 5;
                    ctx.shadowBlur = glow; ctx.shadowColor = "red";
                    ctx.fillStyle = "#ff1744"; ctx.beginPath(); ctx.arc(dx+38, dy-2, 4, 0, Math.PI*2); ctx.fill();
                    ctx.shadowBlur = 0;
                } else {
                    ctx.fillStyle = "black"; ctx.beginPath(); ctx.arc(dx+38, dy-2, 2, 0, Math.PI*2); ctx.fill();
                }

                ctx.strokeStyle="#4e342e"; ctx.lineWidth=2; 
                ctx.beginPath(); ctx.moveTo(dx, dy+15); ctx.lineTo(dx-5, dy+25); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(dx+25, dy+15); ctx.lineTo(dx+30, dy+25); ctx.stroke();
                
                if(i < 2) {
                   ctx.strokeStyle="rgba(255,255,255,0.3)"; ctx.lineWidth=1;
                   ctx.beginPath(); ctx.moveTo(dx+15, dy+5); ctx.lineTo(dx+65, dy+5); ctx.stroke();
                }
            }

            ctx.fillStyle = "#d32f2f";
            ctx.beginPath(); ctx.moveTo(0,0); ctx.bezierCurveTo(0, 30, 60, 30, 70, 0); ctx.fill();
            ctx.strokeStyle = "#ffca28"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(-10, 25); ctx.lineTo(80, 20); ctx.stroke();

            const colors = ["#e91e63", "#9c27b0", "#3f51b5", "#009688", "#ffeb3b", "#ff5722"];
            for(let i=0; i<6; i++) {
                ctx.fillStyle = colors[i]; ctx.fillRect(5 + i*8, -5 - (i%3)*5, 10, 10);
                ctx.fillStyle = "rgba(255,255,255,0.5)"; ctx.fillRect(5 + i*8 + 4, -5 - (i%3)*5, 2, 10);
            }
            
            if(withSanta) drawCharacter(40, -10, 1);
            ctx.restore();
        }

        function drawCharacter(x, y, dir) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(dir, 1);
            if(santa.mode!=='FLYING' && santa.mode!=='APPROACH') {
                 ctx.fillStyle="#3e2723"; ctx.beginPath(); ctx.arc(-12, 5, 10, 0, Math.PI*2); ctx.fill();
            }
            ctx.fillStyle = "#d32f2f"; ctx.beginPath(); ctx.ellipse(0, 0, 12, 16, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#ffccbc"; ctx.beginPath(); ctx.arc(0, -16, 9, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(0, -13, 9, 0, Math.PI, false); ctx.fill();
            ctx.fillStyle = "#d32f2f"; ctx.beginPath(); ctx.moveTo(-9, -20); ctx.lineTo(9, -20); ctx.lineTo(0, -35); ctx.fill();
            ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(0, -35, 4, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        }

        function drawHouseFront(h) {
            ctx.fillStyle = "#795548"; 
            const height = (h.chimBaseY - h.chimTopY) + 15;
            ctx.fillRect(h.chimX - h.chimW/2, h.chimTopY, h.chimW, height);
            ctx.fillStyle = "white";
            ctx.fillRect(h.chimX - h.chimW/2 - 4, h.chimTopY, h.chimW + 8, 10);
        }

        function draw() {
            ctx.clearRect(0,0,width,height);
            drawBackground();

            ctx.save();
            ctx.translate(-camera.x, 0);
            drawGround();

            world.scenery.forEach(s => {
                if(s.x > camera.x - 200 && s.x < camera.x + width + 200) drawSceneryItem(s);
            });

            world.houses.forEach(h => { if(h.x+400>camera.x && h.x-400<camera.x+width) drawHouseBase(h); });
            drawSantaLayer();
            world.houses.forEach(h => { if(h.x+400>camera.x && h.x-400<camera.x+width) drawHouseFront(h); });

            ctx.restore();

            ctx.fillStyle = "rgba(255,255,255,0.8)";
            world.snow.forEach(s => {
                let dx = (s.x-camera.x)%width; if(dx<0)dx+=width;
                ctx.beginPath(); ctx.arc(dx, s.y, s.size, 0, Math.PI*2); ctx.fill();
            });
        }

        function loop() {
            updateWorld();
            updateSanta();
            updateSnow();
            draw();
            requestAnimationFrame(loop);
        }

        window.addEventListener('resize', resize);
        resize();
        initStars();
        initSnow();
        world.houses.push(createHouse(0));
        loop();

    </script>
</body>
</html>
